<!DOCTYPE html><html>	
<head>
	<title>Crypto Wallet</title>	
	<link rel="stylesheet" type="text/css" href="wallet.css">
	<link rel="icon" href="strawicontrans.png">	
	<link rel="manifest" href="manifest.json">
	<link rel="apple-touch-icon" href="strawicontrans.png">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">	
	<meta name="theme-color" content="#fff">	
	<meta name="description" content="A multi-asset cryptocurrency wallet for Nano and Banano, featuring integration with a public directory of addresses. Designed as a single page application emphasizing security, speed, and simplicity. Progressive Web App (PWA) support.">	
	
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
</head>
	
<body>
	<div class="containerdiv">
	<div id="firstDiv" class="firstDiv">
	<div class="objectWrapper" style="margin-top:50px">
		<div id="serverMsg" style="white-space:pre-wrap; color:red; font-style:italic; font-size:0.9em" ></div>
		<div id="serverMsgButton" style="display:none; text-align:center; margin-top:10px; margin-bottom:15px; font-size:0.8em"><button onclick="hideServerMsg()">Hide Message</button></div>
		<div id="quote" style="white-space:pre-wrap; font-style:italic; font-size:0.9em" ></div>
		<strong id="msg" style="display:none; padding:5px; z-index: 4; box-shadow: #ccc 2px 2px 2px; background-color: #fff;
								  position: fixed; left: 0px; top: 0px; border-radius: 5px;
								  pointer-events: none; filter: opacity(0.9);"></strong>
		
		<div style="margin-top:15px; display:flex; align-items:center; position:relative">		
			<select style="margin:auto" name="primary" id="primary" onchange="selectPrimary(event.target.value)">
				<option value="XNO">Nano (XNO)</option>
				<option value="BAN">Banano (BAN)</option>
				<option value="SOL">Solana (SOL)</option>
				<option value="XLM">Stellar (XLM)</option>
			</select>
			<button id="view" style="display:none; font-size:0.8em; position:absolute; right:0px" onclick="toggleView()">All Tools</button>
		</div>
	</div>
	</div>
	<div id="secondDiv" class="secondDiv">
	</div>
	</div>
</body>	

<script>
'use strict';

//////////////////////////////////////////////////////// security quote setup

var localStorageWriteable = true;
if ('serviceWorker' in navigator) {
	navigator.serviceWorker.register('service-worker.js').then((reg) => {
		console.log('Service worker registered.', reg);

		reg.addEventListener('updatefound', () => {
			// An updated service worker has appeared in reg.installing!
			localStorageWriteable = false;
			
			if (localStorage.getItem("quote")) {
				showMsg("Update found. Deleting security quote...");
				D('msg').style.backgroundColor = "#FFB6C1";	
				
				localStorage.removeItem("quote");
				localStorage.clear();
				D('quote').textContent = "";
				
				showMsg("Installing update... Security quote deleted. Clearing DOM...");	
				
				if (ccc) {
					for (let symbol in ccc) {
						ccc[symbol].privateKey = "";						
						if (document.getElementById(`${symbol}-seed`)) document.getElementById(`${symbol}-seed`).value = "";
						ccc[symbol].sidebarElt.innerHTML = "";
						console.log("Deleted " + symbol + "key.");
					}
				}				
				
				showMsg("Installing update... Security quote deleted.");
				let newWorker = reg.installing;
				newWorker.addEventListener('statechange', () => {		
					if (newWorker.state == 'activated') showMsg("Update installed. Security quote deleted.");
				});
			}
		});
	});
}

let quickColorArray = {XNO:'steelblue', BAN:'orange', SOL:'#0ca', XLM:'#373b82'};
if (localStorage.getItem('symbol')) document.getElementById('firstDiv').style.backgroundColor = quickColorArray[localStorage.getItem('symbol')];	
</script>
	
<script src="quotes.js"></script>
<script src="qrcode.js"></script>
<script src="qrscan.js"></script>
<script src="xno.js"></script>
<script src="sol.js"></script>
<script src="xlm.js"></script>
<script src="nacl.js"></script>

<script>
'use strict';

//////////////////////////////////////////////////////// global data

var fullView = localStorage.getItem("view");

var changeNameFlag = false;
var nameCache = {};
var backupCache = {};

const video = document.createElement("video");
var qrScanning = false;
var qrScanningSymbol = D('primary').value;
var qrScanningType = "";	

var clipboardText;		

//////////////////////////////////////////////////////// crypto currency classes

var ccc = {};
ccc['XNO'] = {shift:30, flashColor:'#def', keyType:'seed', min:0, fee:0, donation:'nano_1gpquwssoy8491ajmxp9cxjb3o38imcxidissob7cxc38o6h6r4d8gg639b7',
				server:'https://proxy.powernode.cc/proxy',
				
					gettingStarted:'https://nanolinks.info/',
					faucet: 'https://nanodrop.io/',
					representative:'nano_1natrium1o3z5519ifou7xii8crpxpk8y65qmkih8e8bpsjri651oza8imdd',
					repRec:'https://mynano.ninja/api/accounts/verified'};
						
ccc['BAN'] = {shift:29, flashColor:'#ffc', keyType:'seed', min:0, fee:0, donation:'ban_1gpquwssoy8491ajmxp9cxjb3o38imcxidissob7cxc38o6h6r4d8gg639b7',
				server:'https://kaliumapi.appditto.com/api',
				
					gettingStarted:'https://banano.how/links/',
					faucet: 'https://monkeytalks.cc/',
					representative:'ban_1ka1ium4pfue3uxtntqsrib8mumxgazsjf58gidh1xeo5te3whsq8z476goo',
					repRec:'https://api.spyglass.pw/banano/v1/representatives/scores'};
						
ccc['SOL'] = {shift:9, flashColor:'#e0faf0', keyType:'private key', min:0, fee:5000, donation:'9uugZyizr3QCrTcCgDGHpYwik636GGJVQTYBFRtd2rvG',
				server: new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('mainnet-beta'), 'confirmed'),
				
					gettingStarted:'https://solana.com/',
					faucet: 'https://solfaucet.togatech.org/'};
				
ccc['XLM'] = {shift:7, flashColor:'#edf', keyType:'private key', min:1, fee: StellarSdk.BASE_FEE, donation:'GCOYMN3XAUD4OM4OTNC536TG6MEB6TK3IGSPKDJJJ7V36S3NNGKVBLTC',
				server: new StellarSdk.Server("https://horizon.stellar.org/"), //https://horizon-testnet.stellar.org
				
					gettingStarted:'https://www.stellar.org',
					passphrase: StellarSdk.Networks.PUBLIC}; //.TESTNET
	
for (let symbol in ccc) { 
	ccc[symbol].queue = new Promise(function(resolve, reject) { resolve(true); });
	ccc[symbol].bgColor = quickColorArray[symbol];
}

//////////////////////////////////////////////////////// low level helper functions

ccc['BAN'].generateSeed = function() {
	const seed = new Uint8Array(32);
	crypto.getRandomValues(seed);
	return Array.prototype.map.call(seed, (x) => ('00' + x.toString(16)).slice(-2)).join('').toUpperCase();
};
ccc['XNO'].generateSeed = function() {
	const seed = new Uint8Array(32);
	crypto.getRandomValues(seed);
	return Array.prototype.map.call(seed, (x) => ('00' + x.toString(16)).slice(-2)).join('').toUpperCase();
};
ccc['SOL'].generateSeed = function() { return "[" + solanaWeb3.Keypair.generate().secretKey.toString() + "]"; };
ccc['XLM'].generateSeed = function() { return StellarSdk.Keypair.random().secret(); };

ccc['BAN'].checkSeed = function(seed) { return typeof seed === "string" && /^[0-9a-fA-F]{64}$/.test(seed);};
ccc['XNO'].checkSeed = function(seed) {	return typeof seed === "string" && /^[0-9a-fA-F]{64}$/.test(seed);};
ccc['SOL'].checkSeed = function(seed) {	
	let arrSeed = seed.split(',');
	for (let i = 0; i < arrSeed.length; i++) {
		arrSeed[i] = parseInt(arrSeed[i].replace(/\D/g,''));
		if (!(arrSeed[i] <= 255 && arrSeed[i] >= 0)) return false;
	}
	if (arrSeed.length != 64) return false;
	
	try { solanaWeb3.Keypair.fromSecretKey(new Uint8Array(arrSeed)); }
	catch { return false; }
	return true;
};
ccc['XLM'].checkSeed = function(seed) { return StellarSdk.StrKey.isValidEd25519SecretSeed(seed); };

ccc['XNO'].checkAddress = function(address) { 
	if (!(typeof address === "string") || !/^(xrb_|nano_)[13][13-9a-km-uw-z]{59}$/.test(address)) return false;

	let prefixLength = 5;
	if (address.startsWith('xrb_')) prefixLength = 4;

	const publicKeyBytes = decodeNanoBase32(address.substr(prefixLength, 52));
	const checksumBytes = decodeNanoBase32(address.substr(prefixLength + 52));
	const computedChecksumBytes = blake2b(publicKeyBytes, null, 5).reverse();
	for (let i = 0; i < checksumBytes.length; i++) {
		if (checksumBytes[i] !== computedChecksumBytes[i]) return false;
	}
	return true;
};
ccc['BAN'].checkAddress = function(address) { 
	let nanoAddr = address.replace('ban_', 'nano_');
	return (nanoAddr != address) && ccc['XNO'].checkAddress(nanoAddr);
};
ccc['SOL'].checkAddress = function(address) { return typeof address === "string" && /^[1-9A-HJ-NP-Za-km-z]{44}$/.test(address); };
ccc['XLM'].checkAddress = function(address) { return StellarSdk.StrKey.isValidEd25519PublicKey(address); };

ccc['XNO'].derivePrivateKey = function(seed, index) {
  const indexBuffer = new ArrayBuffer(4)
  const indexView = new DataView(indexBuffer)
  indexView.setUint32(0, index)
  const indexBytes = new Uint8Array(indexBuffer)

  const context = blake2bInit(32)
  blake2bUpdate(context, hexToByteArray(seed))
  blake2bUpdate(context, indexBytes)
  return byteArrayToHex(blake2bFinal(context))
}
ccc['BAN'].derivePrivateKey = ccc['XNO'].derivePrivateKey;

ccc['XNO'].derivePublicKey = function(secretKeyOrAddress) {
	let publicKeyBytes;
	if (!ccc['XNO'].checkAddress(secretKeyOrAddress)) publicKeyBytes = derivePublicFromSecret(hexToByteArray(secretKeyOrAddress));
	else publicKeyBytes = decodeNanoBase32(secretKeyOrAddress.substr(5, 52));
	return byteArrayToHex(publicKeyBytes);
}
ccc['BAN'].derivePublicKey = ccc['XNO'].derivePublicKey;

ccc['XNO'].deriveAddress = function(publicKey) {
  const checksum = blake2b(hexToByteArray(publicKey), null, 5).reverse();
  return 'nano_' + encodeNanoBase32(hexToByteArray(publicKey)) + encodeNanoBase32(checksum);
}
ccc['BAN'].deriveAddress = function(publicKey) { return ccc['XNO'].deriveAddress(publicKey).replace('nano_', 'ban_'); };

ccc['BAN'].unpackSeed = function(seed, index) {
	ccc['BAN'].privateKey = ccc['BAN'].derivePrivateKey(seed, index);
	ccc['BAN'].publicKey = ccc['BAN'].derivePublicKey(ccc['BAN'].privateKey);
	ccc['BAN'].address = ccc['BAN'].deriveAddress(ccc['BAN'].publicKey);	
	ccc['BAN'].index = parseInt(index);
};
ccc['XNO'].unpackSeed = function(seed, index) {
	ccc['XNO'].privateKey = ccc['XNO'].derivePrivateKey(seed, index);
	ccc['XNO'].publicKey = ccc['XNO'].derivePublicKey(ccc['XNO'].privateKey);
	ccc['XNO'].address = ccc['XNO'].deriveAddress(ccc['XNO'].publicKey);
	ccc['XNO'].index = parseInt(index);
}
ccc['SOL'].unpackSeed = function(seed) {
	let arrSeed = seed.split(',');
	for (let i = 0; i < arrSeed.length; i++) {
		arrSeed[i] = parseInt(arrSeed[i].replace(/\D/g,''));
	}
	ccc['SOL'].privateKey = solanaWeb3.Keypair.fromSecretKey(new Uint8Array(arrSeed));
	ccc['SOL'].publicKey = ccc['SOL'].privateKey.publicKey;
	ccc['SOL'].address = ccc['SOL'].publicKey.toBase58();
}
ccc['XLM'].unpackSeed = function(seed) {
	ccc['XLM'].privateKey = seed;
	ccc['XLM'].publicKey = StellarSdk.Keypair.fromSecret(seed).publicKey();
	ccc['XLM'].address = ccc['XLM'].publicKey;
}

ccc['BAN'].addressFromSeed = function(seed) {
	let privateKey = ccc['BAN'].derivePrivateKey(seed, 0);
	let publicKey = ccc['BAN'].derivePublicKey(privateKey);
	return ccc['BAN'].deriveAddress(publicKey);	
}
ccc['XNO'].addressFromSeed = function(seed) {
	let privateKey = ccc['XNO'].derivePrivateKey(seed, 0);
	let publicKey = ccc['XNO'].derivePublicKey(privateKey);
	return ccc['XNO'].deriveAddress(publicKey);	
}
ccc['SOL'].addressFromSeed = function(seed) {
	let arrSeed = seed.split(',');
	for (let i = 0; i < arrSeed.length; i++) {
		arrSeed[i] = parseInt(arrSeed[i].replace(/\D/g,''));
	}
	return solanaWeb3.Keypair.fromSecretKey(new Uint8Array(arrSeed)).publicKey.toBase58()
}
ccc['XLM'].addressFromSeed = function(seed) { return StellarSdk.Keypair.fromSecret(seed).publicKey(); };

//////////////////////////////////////////////////////// information fetch helper functions. Todo: remove connections with DOM somehow

ccc['BAN'].getAccountInfo = function() {
	return post(ccc['BAN'].server, {action: 'account_info', pending: true, representative: true, account: ccc['BAN'].address}).then(function(accountInfo) {
		if (accountInfo && !accountInfo.frontier) {
			accountInfo.balance = "0";
			cyclePending('BAN');
		} return accountInfo;
	});
};
ccc['XNO'].getAccountInfo = function() {
	return post(ccc['XNO'].server, {action: 'account_info', pending: true, representative: true, account: ccc['XNO'].address}).then(function(accountInfo) {
		if (accountInfo && !accountInfo.frontier) {
			accountInfo.balance = "0";			
			cyclePending('XNO');
		} 
		console.log(accountInfo);
		return accountInfo;
	});
};
ccc['SOL'].getAccountInfo = function() {
	return ccc['SOL'].server.getAccountInfo(ccc['SOL'].publicKey).then(function(accountInfo) {
		if (accountInfo) accountInfo.balance = accountInfo.lamports;
		else {
		//	const airdropSignature = await ccc['SOL'].server.requestAirdrop(ccc['SOL'].publicKey, solanaWeb3.LAMPORTS_PER_SOL);
		//	await ccc['SOL'].server.confirmTransaction(airdropSignature);
		//	accountInfo = await ccc['SOL'].server.getAccountInfo(ccc['SOL'].publicKey);
		//	if (accountInfo) {
		//		accountInfo.frontier = true;
		//		accountInfo.balance = accountInfo.lamports;
		//	} else 
			accountInfo = {detail: "Unopened account.", balance: "0"};
		}
		return accountInfo;
	}).catch(function() {showMsg('Unable to connect to network.');});
};
ccc['XLM'].getAccountInfo = async function() {
	return ccc['XLM'].server.loadAccount(ccc['XLM'].publicKey).then(function(accountInfo) {
		accountInfo.balance = rawFromUnit('XLM', accountInfo.balances[0].balance);
		return accountInfo;
	}).catch(function(error) {
		if (error instanceof StellarSdk.NotFoundError) return {detail: "Unopened account.", balance: "0"};
		else showMsg('Unable to connect to network.');
		return false;
	});
};

ccc['BAN'].getFee = function() {};
ccc['XNO'].getFee = function() {};
ccc['SOL'].getFee = function() {
	D('SOL' + '-withdrawal-fee').value = unitFromRaw('SOL', ccc['SOL'].fee);
	D('SOL' + '-withdrawal-fee').parentNode.style.display = 'flex';
	D('SOL' + '-withdrawal-fee').disabled = true;
};
ccc['XLM'].getFee = function() { 
	D('XLM' + '-withdrawal-fee').value = unitFromRaw('XLM', ccc['XLM'].fee);
	D('XLM' + '-withdrawal-fee').parentNode.style.display = 'flex';
	D('XLM' + '-withdrawal-fee').disabled = true;
};



ccc['BAN'].getTransactions = function(start) {nanoDisplayTransactions('BAN', start);};
ccc['XNO'].getTransactions = function(start) {nanoDisplayTransactions('XNO', start);};
ccc['SOL'].getTransactions = function(start) {
	let symbol = 'SOL';
	return ccc[symbol].server.getSignaturesForAddress(ccc[symbol].publicKey, {limit:10, before: start}).then(async function(history) {
	if (history && history.length > 0) {
		flash(D(`${symbol}-heading`), "Transactions");
		if (history.length > 9) {
			D(symbol + '-loadMore').style.display = "";
			D(symbol + '-gettingStarted').style.display = "none";
			D(symbol + '-loadMore').onclick = function() {ccc[symbol].getTransactions(history[history.length - 1].signature);};
		} else {
			D(symbol + '-loadMore').style.display = "none";				
			D(symbol + '-gettingStarted').style.display = "";
		}
		let details = [];
		for (let i = 0; i < history.length; i++) {
			if (!D(symbol + '-' + history[i].slot)) {
				let li = make('li');
				let sign = "+";
				let color = "#333";	
				
				let displayNameSpan = make('span');
				displayNameSpan.id = `${symbol}-${history[i].slot}-display`;
				displayNameSpan.textContent = "Unknown";
				
				li.innerHTML = "<div style='display:flex; justify-content:space-between'><strong style='margin-right:10px'></strong>"
				+ "<strong style='text-align:right; overflow:hidden; text-overflow:ellipsis; color:" + color + "'>" + sign + "<span style='cursor:pointer;'></span> " + symbol + "</strong></div>"
				+ "<div style='display:flex; justify-content:space-between'><span style='cursor:pointer; font-size:0.8em; width:calc(100% - 180px); overflow:hidden; text-overflow:ellipsis; margin-top:4px' onclick='clickCopy(this, this.textContent)'></span>"
				+ "<span style='text-align:right;'></span></div>";
				
				li.firstChild.firstChild.textContent = history[i].slot + ":\xa0";
				li.firstChild.firstChild.appendChild(displayNameSpan);
				li.firstChild.firstChild.nextSibling.firstElementChild.textContent = "0.00";
				
				li.firstChild.nextSibling.firstChild.textContent = history[i].signature;
				li.firstChild.nextSibling.firstChild.id = symbol + '-' + history[i].slot;
				li.firstChild.nextSibling.firstChild.nextSibling.textContent = convertTimestamp(new Date(history[i].blockTime * 1000));
				
				li.style.marginBottom = "15px";
				li.title = history[i].slot;	
				addOrdered(li, D(symbol + '-transactions'));
				// fetchDisplayName(symbol, "-" + history[i].slot + "-display", history[i].signature);
				flash(li);
				details[i] = history[i].signature;  
			}
		}
		if (details.length > 0) {
			let historyDetails = await ccc[symbol].server.getParsedConfirmedTransactions(details);
			if (historyDetails.length > 0) {
				for (let i = 0; i < historyDetails.length; i++) {
					if (D(symbol + '-' + historyDetails[i].slot)) {
						let li = D(symbol + '-' + historyDetails[i].slot).parentNode.parentNode;
						console.log(historyDetails[i]);	
						for (let j = 0; j < historyDetails[i].transaction.message.accountKeys.length; j++) {
							if (historyDetails[i].transaction.message.accountKeys[j].pubkey.toBase58() == ccc[symbol].address) {
								let change = historyDetails[i].meta.postBalances[j] - historyDetails[i].meta.preBalances[j];
								if (historyDetails[i].transaction.message.accountKeys[j].signer) {
									change = -change;
									li.firstChild.firstChild.nextSibling.innerHTML =  '-' + "<span style='cursor:pointer;'></span> " + symbol;
									li.firstChild.firstChild.nextSibling.style.color = "#B00";
								} else li.firstChild.firstChild.nextSibling.style.color = "#097";
								li.firstChild.firstChild.nextSibling.firstElementChild.textContent = unitFromRaw(symbol, change);
							} else if (j < 2) {
								li.firstChild.nextSibling.firstChild.textContent = historyDetails[i].transaction.message.accountKeys[j].pubkey.toBase58();
								fetchDisplayName(symbol, "-" + historyDetails[i].slot + "-display", li.firstChild.nextSibling.firstChild.textContent);
								
								li.firstChild.firstChild.nextSibling.firstElementChild.onclick = function() {
									clickCopy(li.firstChild.firstChild.nextSibling.firstElementChild, li.firstChild.firstChild.nextSibling.firstElementChild.textContent);
								};
								
								li.firstChild.firstChild.firstElementChild.onclick = function() {
									fetchDisplayName(symbol, "-" + historyDetails[i].slot + "-display", li.firstChild.nextSibling.firstChild.textContent, true);
								}
							}
						}
					}
				}
			}
		}
	} else {
		D(symbol + '-loadMore').style.display = "none";				
		D(symbol + '-gettingStarted').style.display = "";
	}
	}).catch(function() {showMsg('Unable to connect to network.');});
};

ccc['XLM'].getTransactions = function(start) {
	let symbol = 'XLM';
	let caller;
	if (start) caller = start();
	else caller = ccc[symbol].server.payments().forAccount(ccc[symbol].address).order("desc").limit(5).call();
	caller.then(function(history) {
		if (history) {
			flash(D(`${symbol}-heading`), "Transactions");
			if (history.records.length == 5) {
				if (!D(symbol + '-' + history.records[history.records.length - 1].id)) {
					D(symbol + '-loadMore').style.display = "";
					D(symbol + '-gettingStarted').style.display = "none";
					D(symbol + '-loadMore').onclick = function() { ccc['XLM'].getTransactions(history.next) };
				}
			} else {
				D(symbol + '-loadMore').style.display = "none";				
				D(symbol + '-gettingStarted').style.display = "";
			}
			console.log(history);
			
			for (let i = 0; i < history.records.length; i++) {
				if (!D(symbol + '-' + history.records[i].id)) {
					let li = make('li');
					let sign = "+";
					let color = "#097";	
					
					let otherAccount = history.records[i].from;
					if (!otherAccount) otherAccount = history.records[i].source_account;
					if (history.records[i].source_account == ccc[symbol].address) {
						sign = "-";
						color = "#B00";
						otherAccount = history.records[i].to;
						if (!otherAccount) otherAccount = history.records[i].account;
					}
					
					let amt = history.records[i].amount;
					if (!amt) amt = history.records[i].starting_balance;
					
					let displayNameSpan = make('span');
					displayNameSpan.id = `${symbol}-${history.records[i].id}-display`;
					displayNameSpan.textContent = "Unknown";
					displayNameSpan.onclick = function() {
						fetchDisplayName(symbol, "-" + history.records[i].id + "-display", otherAccount, true);
					}
					
					li.innerHTML = "<div style='display:flex; justify-content:space-between'><strong style='margin-right:10px'></strong>"
					+ "<strong style='text-align:right; overflow:hidden; text-overflow:ellipsis; color:" + color + "'>" + sign + "<span style='cursor:pointer;'></span> " + symbol + "</strong></div>"
					+ "<div style='display:flex; justify-content:space-between'><span style='cursor:pointer; font-size:0.8em; width:calc(100% - 180px); overflow:hidden; text-overflow:ellipsis; margin-top:4px' onclick='clickCopy(this, this.textContent)'></span>"
					+ "<span style='text-align:right;'></span></div>";
					
					li.firstChild.firstChild.textContent = history.records[i].id + ":\xa0";
					li.firstChild.firstChild.appendChild(displayNameSpan);
					li.firstChild.firstChild.nextSibling.firstElementChild.textContent = unitFromRaw(symbol, rawFromUnit(symbol, amt));
					li.firstChild.firstChild.nextSibling.firstElementChild.onclick = function() {
						clickCopy(li.firstChild.firstChild.nextSibling.firstElementChild, li.firstChild.firstChild.nextSibling.firstElementChild.textContent);
					};
					
					li.firstChild.nextSibling.firstChild.textContent = otherAccount;
					li.firstChild.nextSibling.firstChild.id = symbol + '-' + history.records[i].id;
					li.firstChild.nextSibling.firstChild.nextSibling.textContent = convertTimestamp(new Date(history.records[i].created_at));
					
					li.style.marginBottom = "15px";
					li.title = history.records[i].id;			
					addOrdered(li, D(symbol + '-transactions'));
					fetchDisplayName(symbol, "-" + history.records[i].id + "-display", otherAccount);
					flash(li);
				}
			}
		}
	}).catch(function(error) {});
};

function nanoDisplayTransactions(symbol, start) {
	post(ccc[symbol].server, { action: 'account_history', head:start, account: ccc[symbol].address, count:10 }).then(function(history) {
		if (history && history.history) {		
			flash(D(`${symbol}-heading`), "Transactions");
			if (history.previous) {
				if (!D(symbol + '-' + history.history[history.history.length - 1].height)) {
					D(symbol + '-loadMore').style.display = "";
					D(symbol + '-gettingStarted').style.display = "none";
					D(symbol + '-loadMore').onclick = function() {ccc[symbol].getTransactions(history.previous);};
				}
			} else {
				D(symbol + '-loadMore').style.display = "none";				
				D(symbol + '-gettingStarted').style.display = "";
			}
			for (let i = 0; i < history.history.length; i++) {
				if (!D(symbol + '-' + history.history[i].height)) {
					let li = make('li');
					let sign = "+";
					let color = "#097";				
					if (history.history[i].type == "send") {
						sign = "-";
						color = "#B00";
					}
					
					let displayNameSpan = make('span');
					displayNameSpan.id = `${symbol}-${history.history[i].height}-display`;
					displayNameSpan.textContent = "Unknown";
					displayNameSpan.onclick = function() {
						fetchDisplayName(symbol, "-" + history.history[i].height + "-display", history.history[i].account, true);
					}
					
					li.innerHTML = "<div style='display:flex; justify-content:space-between'><strong style='margin-right:10px'></strong>"
					+ "<strong style='text-align:right; overflow:hidden; text-overflow:ellipsis; color:" + color + "'>" + sign + "<span style='cursor:pointer;'></span> " + symbol + "</strong></div>"
					+ "<div style='display:flex; justify-content:space-between'><span style='cursor:pointer; font-size:0.8em; width:calc(100% - 180px); overflow:hidden; text-overflow:ellipsis; margin-top:4px' onclick='clickCopy(this, this.textContent)'></span>"
					+ "<span style='text-align:right;'></span></div>";
					
					li.firstChild.firstChild.textContent = history.history[i].height + ":\xa0";
					li.firstChild.firstChild.appendChild(displayNameSpan);
					li.firstChild.firstChild.nextSibling.firstElementChild.textContent = unitFromRaw(symbol, history.history[i].amount);
					li.firstChild.firstChild.nextSibling.firstElementChild.onclick = function() {
						clickCopy(li.firstChild.firstChild.nextSibling.firstElementChild, li.firstChild.firstChild.nextSibling.firstElementChild.textContent);
					};
					
					li.firstChild.nextSibling.firstChild.textContent = history.history[i].account;
					li.firstChild.nextSibling.firstChild.id = symbol + '-' + history.history[i].height;
					li.firstChild.nextSibling.firstChild.nextSibling.textContent = convertTimestamp(new Date(history.history[i].local_timestamp * 1000));
					
					li.style.marginBottom = "15px";
					li.title = history.history[i].height;			
					addOrdered(li, D(symbol + '-transactions'));
					fetchDisplayName(symbol, "-" + history.history[i].height + "-display", history.history[i].account);
					flash(li);
				}
			}
		}
	});
}

ccc['XNO'].getPending = async function() {return (await post(ccc['XNO'].server, {action: 'pending', account: ccc['XNO'].address, source:true})).blocks;};
ccc['BAN'].getPending = async function() {return (await post(ccc['BAN'].server, {action: 'pending', account: ccc['BAN'].address, source:true})).blocks;};

//////////////////////////////////////////////////////// transaction helper functions

ccc['BAN'].sendTo = function(destination, amt) { return enqueue('BAN', function() {return nanoSend('BAN', destination, amt);}); };
ccc['XNO'].sendTo = function(destination, amt) { return enqueue('XNO', function() {return nanoSend('XNO', destination, amt);}); };
ccc['SOL'].sendTo = function(destination, amt) { 
	return enqueue('SOL', async function() {
		let transaction = new solanaWeb3.Transaction().add(
			solanaWeb3.SystemProgram.transfer({fromPubkey: ccc['SOL'].publicKey, toPubkey: new solanaWeb3.PublicKey(destination), lamports: rawFromUnit('SOL', amt)})
		);
		// Sign transaction, broadcast, and confirm
		try {
			let signature = await solanaWeb3.sendAndConfirmTransaction(ccc['SOL'].server, transaction, [ccc['SOL'].privateKey]);
			refreshBalance('SOL');
			return signature;
		} catch { return false; }
	});
};
ccc['XLM'].sendTo = function(destination, amt) { 
	var sourceKeys = StellarSdk.Keypair.fromSecret(ccc['XLM'].privateKey);
	var transaction;
	return ccc['XLM'].server.loadAccount(destination).then(function() {
		return ccc['XLM'].server.loadAccount(sourceKeys.publicKey()).then(function (sourceAccount) {
			transaction = new StellarSdk.TransactionBuilder(sourceAccount, { fee: StellarSdk.BASE_FEE, networkPassphrase: ccc['XLM'].passphrase})
				.addOperation(StellarSdk.Operation.payment({destination: destination, asset: StellarSdk.Asset.native(), amount: amt}))
				.setTimeout(180).build();
			transaction.sign(sourceKeys);
			return ccc['XLM'].server.submitTransaction(transaction);
		}).then(function (result) {
			console.log("Success! Results:", result);
			refreshBalance('XLM');
			return result;
		}).catch(function (error) {
			console.error("Something went wrong!", error);
			return false;
		});
	}).catch(function (error) {
		if (error instanceof StellarSdk.NotFoundError) {
			if (parseFloat(amt) < 1) {
				showMsg("Destination is a new account. Minimum send: " + ccc['XLM'].min + " XLM.");
				return {msgHandled:true};
			} else return ccc['XLM'].server.loadAccount(sourceKeys.publicKey()).then(function (sourceAccount) {
				transaction = new StellarSdk.TransactionBuilder(sourceAccount, { fee: StellarSdk.BASE_FEE, networkPassphrase: ccc['XLM'].passphrase})
					.addOperation(StellarSdk.Operation.createAccount({destination: destination, startingBalance: amt}))
					.addMemo(StellarSdk.Memo.text("Account creation")).setTimeout(180).build();
				transaction.sign(sourceKeys);
				return ccc['XLM'].server.submitTransaction(transaction);
			}).then(function (result) {	
				console.log("Success! Results:", result);
				refreshBalance('XLM');
				return result;
			}).catch(function (error) {
				console.error("Something went wrong!", error);
				return false;
			});
		} else return false;
	});
};

ccc['BAN'].receive = function(hash) { return enqueue('BAN', function() {return nanoReceive('BAN', hash);}); };
ccc['XNO'].receive = function(hash) { return enqueue('XNO', function() {return nanoReceive('XNO', hash);}); };

ccc['BAN'].changeRep = function(newrep) { return enqueue('BAN', function() {return nanoChange('BAN', newrep);}); };
ccc['XNO'].changeRep = function(newrep) { return enqueue('XNO', function() {return nanoChange('XNO', newrep);}); };

ccc['BAN'].confirmBlock = function(hash) {return nanoConfirm('BAN', hash);};
ccc['XNO'].confirmBlock = function(hash) {return nanoConfirm('XNO', hash);};

ccc['XNO'].createBlock = function(secretKey, data) {
	if (typeof data.work === 'undefined') throw new Error('Work is not set');
	if (!ccc['XNO'].checkAddress(data.representative)) throw new Error('Representative is not valid');

	let correctedPrevious = data.previous;
	if (data.previous === null) correctedPrevious = BLANK_HASH;

	let linkIsAddress = false;
	let correctedLink = data.link;
	if (data.link === null) correctedLink = BLANK_HASH;
	else if (ccc['XNO'].checkAddress(correctedLink)) linkIsAddress = true;
	if (correctedPrevious === BLANK_HASH && (linkIsAddress || correctedLink === BLANK_HASH)) throw new Error('Block is impossible');

	let publicKey = ccc['XNO'].derivePublicKey(secretKey);
	let linkBytes;
	if (ccc['XNO'].checkAddress(correctedLink)) linkBytes = hexToByteArray(ccc['XNO'].derivePublicKey(correctedLink));
	else linkBytes = hexToByteArray(correctedLink);
	
	const context = blake2bInit(32)
	blake2bUpdate(context, STATE_BLOCK_PREAMBLE_BYTES)
	blake2bUpdate(context, hexToByteArray(publicKey))
	blake2bUpdate(context, hexToByteArray(correctedPrevious))
	blake2bUpdate(context, hexToByteArray(ccc['XNO'].derivePublicKey(data.representative)))
	blake2bUpdate(context, hexToByteArray(BigInt(data.balance).toString(16).padStart(32, '0')))
	blake2bUpdate(context, linkBytes)
	const hashBytes = blake2bFinal(context)
	let link
	let linkAsAddress
	if (linkIsAddress) {
		linkAsAddress = correctedLink
		link = ccc['XNO'].derivePublicKey(linkAsAddress)
	} else {
		link = correctedLink
		linkAsAddress = ccc['XNO'].deriveAddress(link)
	}
	const block = {
		type: 'state',
		account: ccc['XNO'].deriveAddress(publicKey),
		previous: correctedPrevious,
		representative: data.representative,
		balance: data.balance,
		link,
		// eslint-disable-next-line @typescript-eslint/camelcase
		link_as_account: linkAsAddress,
		work: data.work,
		signature: byteArrayToHex(signDetached(hashBytes, hexToByteArray(secretKey))),
	}
	return { hash: byteArrayToHex(hashBytes), block: block };
}
ccc['BAN'].createBlock = ccc['XNO'].createBlock;

async function nanoSend(symbol, destination, amt) {
	console.log('Sending '+ amt +' Nano from address '+ ccc[symbol].address +' to '+ destination);
	// check frontier
	let frontierBlock = await fetchFrontier(symbol, await refreshBalance(symbol));
	if (!frontierBlock) return false;
	
	console.log("Fetched frontier confirmed check; send proceed: " + frontierBlock.balance);
	return await postBlock(symbol, 'send', frontierBlock.hash, frontierBlock.hash, frontierBlock.representative, 
		(BigInt(frontierBlock.balance) - BigInt(rawFromUnit(symbol, amt))).toString(), destination);
}

async function nanoReceive(symbol, hash) {
	console.log('Receiving in address '+ ccc[symbol].address +' from block '+ hash);
	let blockInfoFetch = post(ccc[symbol].server, {action: 'block_info', json_block: true, hash: hash});
	let oldBalance = '0';
	let previous = '0'.padStart(64, '0');
	let representative = ccc[symbol].representative;
	let workInput = ccc[symbol].publicKey;
	
	let frontierBlock = await fetchFrontier(symbol, await refreshBalance(symbol));
	if (frontierBlock) {
		oldBalance = frontierBlock.balance;
		previous = frontierBlock.hash;
		representative = frontierBlock.representative;
		workInput = frontierBlock.hash;
	} else {
		console.log("Fetched frontier failed check; attempting open block.");
		await suggestRep(symbol);
		representative = ccc[symbol].representative;
	}
	
	return await blockInfoFetch.then(async function(blockInfo) {
		if (!blockInfo) return false;
		return await postBlock(symbol, 'receive', workInput, previous, representative, (BigInt(oldBalance) + BigInt(blockInfo.amount)).toString(), hash);
	});
};

async function nanoChange(symbol, newrep) {
	console.log('Changing rep of '+ ccc[symbol].address +' to '+ newrep);
	// check frontier
	let frontierBlock = await fetchFrontier(symbol, await refreshBalance(symbol));
	if (!frontierBlock) return false;
	
	console.log("Fetched frontier confirmed check; change proceed: " + frontierBlock.balance);	
	return await postBlock(symbol, 'change', frontierBlock.hash, frontierBlock.hash, newrep, frontierBlock.balance, '0'.padStart(64, '0'));
}

function fetchFrontier(symbol, accountInfo) {
	if (accountInfo && accountInfo.frontier) return post(ccc[symbol].server, {action: 'block_info', json_block: true, hash: accountInfo.frontier}).then(function(res) {
		if (!res) return false;
		let fetchedFrontierBlock = res.contents;

		let producedFrontierBlock = ccc[symbol].createBlock(ccc[symbol].privateKey, {
			work: fetchedFrontierBlock.work,
			previous: fetchedFrontierBlock.previous,
			representative: accountInfo.representative.replace('ban_', 'nano_'),
			balance: accountInfo.balance,
			link: fetchedFrontierBlock.link
		}).block;	
		if (fetchedFrontierBlock.signature != producedFrontierBlock.signature) {
			console.error("Frontier failed verification. This should NOT happen.");
			console.log(fetchedFrontierBlock);
			console.log(producedFrontierBlock);
			alert("Frontier block failed verification. This is fishy.");
			return false;
		}
		fetchedFrontierBlock.hash = accountInfo.frontier;
		return fetchedFrontierBlock;
	});
	else {
		console.log(accountInfo);
		return false;
	}
}

async function postBlock(symbol, subtype, workInput, previous, representative, balance, link) {
	let rawWorkThreshold = await post(ccc[symbol].server, { action: 'active_difficulty' });
	let work_threshold = rawWorkThreshold.network_current;
	if (subtype == 'receive') work_threshold = rawWorkThreshold.network_receive_current;

	console.log('Computing work for subtype "'+ subtype +'", difficulty: '+ work_threshold +' (work being done locally: '+ false +')');
	let work = (await post(ccc[symbol].server, {action: 'work_generate', hash: workInput, difficulty: work_threshold})).work;
	if (work === undefined) work = null;
	
	let block = ccc[symbol].createBlock(ccc[symbol].privateKey, {
		work: work,
		previous: previous,
		representative: representative.replace('ban_', 'nano_'),
		balance: balance,
		link: link.replace('ban_', 'nano_')
	});
	
	if (symbol == "BAN") {
		block.block.representative = block.block.representative.replace('nano_', 'ban_');
		block.block.representative = block.block.representative.replace('xrb_', 'ban_');
		block.block.account = block.block.account.replace('nano_', 'ban_');
		block.block.account = block.block.account.replace('xrb_', 'ban_');
		delete block.block.link_as_account;
	}
	
	let formData = {action: 'process', json_block: true, subtype: subtype, block: block.block};
	if (work === null) {
		formData.do_work = true;
		formData.block.work = undefined;
	}
	console.log(subtype + ' block:');
	console.log(block);
	post(ccc[symbol].server, formData);
	let confirmation = ccc[symbol].confirmBlock(block.hash);
	confirmation.then(function(theBlock) {
		if (D(`${symbol}-rep`).textContent != theBlock.contents.representative) {
			flash(D(`${symbol}-rep`), theBlock.contents.representative);	
			fetchDisplayName(symbol, "-rep-display", theBlock.contents.representative);
		}			
		flash(D(`${symbol}-balance`), unitFromRaw(symbol, theBlock.contents.balance));
	});
	return confirmation;
}

function nanoConfirm(symbol, hash) {
	return new Promise(async function(resolve, reject) {
		let firstBlockInfo = await post(ccc[symbol].server, {action: 'block_info', json_block: true, hash: hash});
		if (firstBlockInfo.confirmed == "true") resolve(firstBlockInfo);
		else {
			let counter = 0;
			waitCheckHash();
			function waitCheckHash() {
				setTimeout(async function() {
					let blockInfo = await post(ccc[symbol].server, {action: 'block_info', json_block: true, hash: hash});
					if (blockInfo.confirmed == "true") resolve(blockInfo);
					else if (counter < 10) {
						counter++;
						waitCheckHash();
					} else resolve();
				}, 1000);
			}
		}
	});
}

//////////////////////////////////////////////////////// Exchange websocket and other setup

let nanoCount = 0;
let ninjaPromise = fetch('https://mynano.ninja/api/accounts/aliases').then(function(response) { response.json().then(function(data) { 
	if (data) {
		for (let i = 0; i < data.length; i++) {
			if (!backupCache[data[i].account]) {
				backupCache[data[i].account] = data[i].alias;
				nanoCount++;
			}
		}
	}	
	console.log("Nano ninja count: " + nanoCount);
});});

let lookerPromise = fetch('https://nanolooker.com/api/known-accounts-balance').then(function(response) { response.json().then(function(data) { 
	if (data) {
		for (let i = 0; i < data.length; i++) {
			if (!backupCache[data[i].account]) {
				backupCache[data[i].account] = data[i].alias;
				nanoCount++;
			}
		}
	}		
	console.log("Nano looker count: " + nanoCount);
});});	

ninjaPromise.then(function() { lookerPromise.then(function() {
fetch('https://nano.to/known').then(function(response) { response.json().then(function(data) { 
	if (data) {
		for (let i = 0; i < data.length; i++) {
			if (!backupCache[data[i].address]) {
				backupCache[data[i].address] = data[i].name;
				nanoCount++;
			}
		}
	}
	console.log("Nano to count: " + nanoCount);
});});
});});

let bananoCount = 0;
fetch('https://api.spyglass.pw/banano/v1/known/accounts',{ method: 'POST' }).then(function(response) { response.json().then(function(data) { 
	if (data) {
		for (let i = 0; i < data.length; i++) {
			if (!backupCache[data[i].address]) {
				backupCache[data[i].address] = data[i].alias;
				bananoCount++;
			}
		}
	}
	console.log("Banano spyglass count: " + bananoCount);
});});

fetch('https://bananolooker.com/api/known-accounts').then(function(response) { response.json().then(function(data) { 
	if (data) {
		for (let i = 0; i < data.length; i++) {
			if (!backupCache[data[i].account]) {
				backupCache[data[i].account] = data[i].alias;
				bananoCount++;
			}
		}
	}
	console.log("Banano looker count: " + bananoCount);
});});

function exchangeURL() {
	if ((new Date()).getDate() < 15) return 'wss://warashibetrader.herokuapp.com';
	else return 'wss://wrsbtrader.herokuapp.com';
}

var ws = new WebSocket(exchangeURL());
setupWebsocket(ws);

function setupWebsocket() {
	ws.onopen = function() { 
		if (ccc[D('primary').value].address) fetchDisplayName(D('primary').value, "-display", ccc[D('primary').value].address);
		console.log("Exchange RC!"); 
	};
	ws.onclose = function() { 
		console.log("Exchange DC."); 
		ws = new WebSocket(exchangeURL());
		setupWebsocket();
	}

	ws.customEvents = {};
	ws.on = function(cueName, eventAction) { ws.customEvents[cueName] = eventAction; };
	ws.emit = function(cueName, payload) { 
		if (ws.readyState == 1) {
			ws.send(JSON.stringify({cueName:cueName, payload:payload})); 
			return true;
		} else return false;
	};
	ws.onmessage = function(event) {
		let data;
		try { 
			data = JSON.parse(event.data); 
			if (data && data.cueName && ws.customEvents[data.cueName]) ws.customEvents[data.cueName](data.payload);
			else {
				showMsg("Unrecognized server message.")
				console.error(event.data);
			}
		}
		catch { 
			showMsg("Unrecognized server message.")
			console.error(event.data);
		}	
	};

	// Custom commands	
	ws.on('serverMsgCue', async function(data) {
		if (typeof data === "string" && localStorage.getItem("serverMsg") != data) {
			D('serverMsg').textContent = data;
			D('serverMsg').style.display = "";
			D('serverMsgButton').style.display = "";
		}
	});
	
	ws.on('setNameChallengeCue', async function(data) {
		if (changeNameFlag) {	
			showMsg("Processing representative challenge...",null,true);	
			await ccc[data.currency].changeRep(data.pendingRep);
			ws.emit("setNameReplyCue", data);
			showMsg("Confirming representative challenge...", null,true);
		}
	});
	
	ws.on('setNameCompletedCue', async function(data) {	
		if (changeNameFlag) {
			nameCache[data.address] = data.display;
			localStorage.setItem(`${data.currency}-display`, JSON.stringify({address:data.address, name:data.display}));
			displayName(data.currency, "-display", data.address, data.display);
			if (ccc[data.currency].representative) {
				showMsg("Restoring representative...");	
				await ccc[data.currency].changeRep(changeNameFlag);
			}
			showMsg("Display name updated.");
			changeNameFlag = false;
		}
	});
	
	ws.on('setNameFailedCue', function(data) {	
		showMsg("\"Open\" the account first by receiving funds.");
		changeNameFlag = false;
	});	
	
	ws.on('getNameReplyCue', function(data) {
		nameCache[data.address] = data.display;
		if (data.div == "-display") localStorage.setItem(`${data.currency}-display`, JSON.stringify({address:data.address, name:data.display}));
		if (data.div == "-rep-display") localStorage.setItem(`${data.currency}-rep-display`, JSON.stringify({address:data.address, name:data.display}));
		displayName(data.currency, data.div, data.address, data.display);
	});
}

for (let symbol in ccc) {generateHTML(symbol);}
if (localStorage.getItem('symbol')) D('primary').value = localStorage.getItem('symbol');
selectPrimary(D('primary').value);

//////////////////////////////////////////////////////// Interface with helper functions, and websocket

function setName(symbol) {
	if (D(symbol + "-set-display").value.length > 64) showMsg("64 characters or fewer.");
	else {
		if (ws.emit("setNameCue", {display:D(symbol + "-set-display").value, address: ccc[symbol].address, currency: symbol})) {
			showMsg("Setting display name...", null,true);
			changeNameFlag = D(`${symbol}-rep`).textContent;
		} else showMsg("Unable to connect to directory.");
	}
}

function fetchDisplayName(symbol, divString, address, skipCache) {
	if (ccc[symbol].checkAddress(address)) {	
		let displayString = nameCache[address];
		if (!displayString) {
			if (divString == "-display") {
				let myDisplay = localStorage.getItem(`${symbol}-display`);
				if (myDisplay) myDisplay = JSON.parse(myDisplay);
				if (myDisplay && myDisplay.address == address) displayString = myDisplay.name;
			} else if (divString == "-rep-display") {
				let myDisplay = localStorage.getItem(`${symbol}-rep-display`);
				if (myDisplay) myDisplay = JSON.parse(myDisplay);
				if (myDisplay && myDisplay.address == address) displayString = myDisplay.name;
			}
		}
		displayName(symbol, divString, address, displayString);
	
		if ((!displayString || skipCache) && !ws.emit("getNameCue", {div: divString, address: address, currency: symbol})) {
			setTimeout(function() {ws.emit("getNameCue", {div: divString, address: address, currency: symbol})}, 1000);
		}
	} else D(symbol + divString).textContent = "";
}

function displayName(symbol, divString, address, displayString) {
	if (!displayString) displayString = backupCache[address];
	if (!displayString) {
		if (divString == "-display") {
			if (ccc[symbol].index === 0 || ccc[symbol].index > 0) displayString = "My Account #" + ccc[symbol].index + " (Unknown)";
			else displayString = "My Account (Unknown)";
		} else if (address == ccc[symbol].address) displayString = "(me)";
		else displayString = "Unknown";
	} else if (divString != "-display" && address == ccc[symbol].address) displayString += " (me)";
	flash(D(symbol + divString), displayString);
}

//////////////////////////////////////////////////////// Interface with helper functions
	
function generateWallet(symbol) {
	D(`${symbol}-seed`).value = ccc[symbol].generateSeed(); 	
	navigator.clipboard.writeText(D(`${symbol}-seed`).value);
	clipboardText = D(`${symbol}-seed`).value;
		showMsg("New " + ccc[symbol].keyType + " copied to clipboard. Save it securely (elsewhere and NOW).");
	flash(D(`${symbol}-seed`));
	D(`${symbol}-generateButton`).disabled = true;
}

function importWallet(symbol) {
	let seed = D(`${symbol}-seed`).value;
	let index = D(`${symbol}-index`).value;
	if (index.length == 0 && (symbol == "XNO" || symbol == "BAN")) index = 0;
	if (!ccc[symbol].checkSeed(seed)) {
		if (!ccc[symbol].checkAddress(seed)) showMsg("Invalid " + ccc[symbol].keyType  +".");
		else showMsg("Submit a " + ccc[symbol].keyType  + ", not an address.");
	}
	else if (index.length > 0 && (!/^[0-9]+$/.test(index) || index < 0 || index > Math.pow(2, 32) - 1)) showMsg("Invalid account index.");
	else {
		showMsg(`Loading ${symbol} account...`, null,true);
		clearWallet(symbol);
		
		ccc[symbol].unpackSeed(seed, parseInt(index));
		flash(D(`${symbol}-address`), ccc[symbol].address);	
		addressQR(symbol);
		D(symbol + "-gray").style.display = "";
		D(symbol + "-load").textContent = "Switch Account";		
		D("view").style.display = "";

		updateView(symbol);	
		
		fetchDisplayName(symbol, "-display", ccc[symbol].address);
		refreshBalance(symbol, true).then(function(accountInfo) {
			if (localStorageWriteable) {
				localStorage.setItem(`${symbol}-seed`, seed);
				localStorage.setItem(`${symbol}-index`, index);
				localStorage.setItem(`${symbol}-address`, ccc[symbol].address);
				if (accountInfo) localStorage.setItem(`${symbol}-info`, JSON.stringify(accountInfo));
				else localStorage.setItem(`${symbol}-info`, "");
			}
		});
		ccc[symbol].getFee();	
		ccc[symbol].getTransactions();	
	}
}

function clickClearWallet(symbol) {
	clearWallet(symbol);
	
	D(`${symbol}-seed`).value = ""; 
	D(`${symbol}-generateButton`).disabled = false;
	D(`${symbol}-index`).value = ""; 	
	
	localStorage.removeItem(`${symbol}-seed`); 
	localStorage.removeItem(`${symbol}-index`); 
	localStorage.removeItem(`${symbol}-display`); 
	localStorage.removeItem(`${symbol}-rep-display`); 
	localStorage.removeItem(`${symbol}-info`);
	
	flash(D(`${symbol}-dest-display`), "");
	D(symbol + "-dest").value = "";	
	D(`${symbol}-withdrawal-amount`).value = "";
	
	updateView(symbol);
	D('firstDiv').scrollTo(0, 0);
}

function clearWallet(symbol) {
	nameCache = {};
	qrclose();
	clearDOM(D(symbol + '-transactions'));	
	D(symbol + '-loadMore').style.display = "none";
	D(symbol + '-gettingStarted').style.display = "";
	
	ccc[symbol].privateKey = "";
	ccc[symbol].publicKey = "";
	ccc[symbol].address = "";
	ccc[symbol].index = "";
	
	flash(D(`${symbol}-display`), "My Account (Unknown)");	
	flash(D(`${symbol}-address`), "\xa0");	
	flash(D(`${symbol}-balance`), "0.00");
	flash(D(`${symbol}-balance-pending`), "0.00");
	flash(D(`${symbol}-rep`), "\xa0");	
	flash(D(`${symbol}-rep-display`), "");
	flash(D(`${symbol}-new-rep-display`), "");
	
	D(symbol + "-new-rep").value = "";	
	D(symbol + '-qr-input').value = "";
	ccc[symbol].qrCode.makeCode("");
	
	if (D(symbol + "-editpanel").style.display != "none") toggleEdit(symbol);
	
	//D(symbol + "-gray").style.filter = "opacity(0.5)";
	D(symbol + "-gray").style.display = "none";
	D(symbol + "-load").textContent = "Load Account";
}

function refreshBalance(symbol, confirm) {
	if (ccc[symbol].address) {
		return ccc[symbol].getAccountInfo().then(function(accountInfo) {
			if (accountInfo) {
				if (confirm) showMsg(`${symbol} account loaded.`);
				else if (D('msg').textContent.indexOf('Unable to connect to network.') != -1) showMsg(`Connected.`);
				localStorage.setItem(`${symbol}-info`, JSON.stringify(accountInfo));	
			} else {
				if (ccc[symbol].address == localStorage.getItem(`${symbol}-address`)) accountInfo = localStorage.getItem(`${symbol}-info`);
				if (accountInfo) accountInfo = JSON.parse(accountInfo);
			}
			
			if (accountInfo) {
				if (accountInfo.representative && D(`${symbol}-rep`) && D(`${symbol}-rep`).textContent != accountInfo.representative) {
					flash(D(`${symbol}-rep`), accountInfo.representative);	
					fetchDisplayName(symbol, "-rep-display", accountInfo.representative);
				}
				if (accountInfo.balance !== undefined) flash(D(`${symbol}-balance`), unitFromRaw(symbol, accountInfo.balance));
				if (accountInfo.pending !== undefined) flash(D(`${symbol}-balance-pending`), unitFromRaw(symbol, accountInfo.pending));
			}
			
			return accountInfo;
		});	
	} else return false;
}

async function cyclePending(symbol) {
	if (ccc[symbol].address) {
		showMsg(`Collecting arriving ${symbol}...`, null,true);
		const pending = await ccc[symbol].getPending();
		for (const block in pending) {
			await ccc[symbol].receive(block);
		}
		ccc[symbol].getTransactions();	
		D(`${symbol}-balance-pending`).textContent = "0.00";
		showMsg("Arriving " + symbol + " collected.");		
	} 
}

async function withdraw(symbol) {
	if (ccc[symbol].checkAddress(ccc[symbol].address) && ccc[symbol].checkAddress(D(`${symbol}-dest`).value)) {
		let amtWithFee = BigInt(rawFromUnit(symbol, D(`${symbol}-withdrawal-amount`).value)) + BigInt(ccc[symbol].fee);
		if ((D(`${symbol}-withdrawal-amount`).value.match(/\./g)||[]).length <= 1 
		&& /^[0-9.]+$/.test(D(`${symbol}-withdrawal-amount`).value) 
		&& amtWithFee <= BigInt(rawFromUnit(symbol, D(`${symbol}-balance`).textContent))) {
			if (amtWithFee + BigInt(rawFromUnit(symbol, ccc[symbol].min)) <= BigInt(rawFromUnit(symbol, D(`${symbol}-balance`).textContent))) {
				showMsg(symbol + " transfer initiated...", null,true);
				let sendResp = await ccc[symbol].sendTo(D(`${symbol}-dest`).value, D(`${symbol}-withdrawal-amount`).value);
				if (sendResp) {
					if (!sendResp.msgHandled) {
						showMsg(D(`${symbol}-withdrawal-amount`).value + " " + symbol + " transferred.");
						D(`${symbol}-withdrawal-amount`).value = "";
					}
					ccc[symbol].getTransactions();
				} else showMsg("Transfer seems to have failed.");
			} else showMsg("Minimum account balance is " + ccc[symbol].min + " " + symbol + ".");
		} else showMsg("Insufficient funds.");
	} else showMsg("Invalid address.");
}

async function setRep(symbol) {
	if (!ccc[symbol].checkAddress(D(`${symbol}-rep`).textContent)) showMsg("\"Open\" the account first by receiving funds.");
	else if (!ccc[symbol].checkAddress(D(`${symbol}-new-rep`).value)) showMsg("Invalid address.");
	else {
		showMsg("Updating representative...", null,true);
		await ccc[symbol].changeRep(D(`${symbol}-new-rep`).value);
		showMsg("Representative updated.");
	}
}

function suggestRep(symbol) {
	return fetch(ccc[symbol].repRec).then(function(response) {
		return response.json().then(function(data) { 
			if (data) {
				data.sort(function(x, y) { return y.score - x.score; });
				console.log(data[0]);
				let repAddr = data[0].account;
				if (!repAddr) repAddr = data[0].address;
				if (repAddr) {
					ccc[symbol].representative = repAddr;
					D(`${symbol}-new-rep`).value = repAddr;
					flash(D(`${symbol}-new-rep`));
					fetchDisplayName(symbol, '-new-rep-display', repAddr);
				}
			}
		});
	}).catch(function() {showMsg('Unable to connect to network.');});
}

function toggleVisibility(symbol) {
	let x = D(`${symbol}-seed`);
	if (x.type === "password") {
		x.type = "text";
		D(symbol + '-show').classList.add('active');
	} else {
		x.type = "password";		
		D(symbol + '-show').classList.remove('active');
	}
}

function toggleEdit(symbol) {
	if (D(symbol + "-editpanel").style.display == "none") {
		D(symbol + "-editpanel").style.display = "";
		D(symbol + "-editbutton").classList.add('active');
	} else {
		D(symbol + "-editpanel").style.display = "none";
		D(symbol + "-set-display").value = "";
		D(symbol + "-editbutton").classList.remove('active');
	}
}

function donate(symbol) {
	D(symbol + "-dest").parentNode.scrollIntoView({block:"center", behavior:"auto"});
	D(symbol + "-dest").value = ccc[symbol].donation;
	flash(D(symbol + "-dest"));
	fetchDisplayName(symbol, '-dest-display', D(symbol + "-dest").value);
}

function toggleView(symbol) {
	if (fullView) {
		fullView = false;
		localStorage.removeItem("view");
	} else {
		fullView = true;
		localStorage.setItem("view", "true");
	}
	updateView(symbol);
}

var currentElt;

function scrollPanel(elt) {
	if (screen.width <= 550 || screen.height <= 550 && ccc[D('primary').value].address) {
		elt.parentNode.scrollIntoView({block:'start', behavior:'auto', inline: "nearest"});	
		currentElt = elt;
		setTimeout(function() {currentElt = null;}, 1000);
	}
}

if (screen.width <= 550 || screen.height <= 550) {
	window.addEventListener("resize", function() {
		if (currentElt) currentElt.parentNode.scrollIntoView({block:'start', behavior:'auto', inline: "nearest"});	
	});
}


window.addEventListener('copy', function(e) {
	if (document.getSelection().toString()) clipboardText = document.getSelection().toString();
});

window.addEventListener('keydown', function(evt) {
	if (evt.altKey) {
		if (evt.keyCode == 81) {
			evt.preventDefault();
			toggleView(D('primary').value);
			//D('primary').focus();
		}
		if (evt.keyCode == 49) {
			evt.preventDefault();
			//toggleView(D('primary').value);
			D('primary').focus();
		}
	}
});

function closeCopy(obj) {
	if (obj.value.length > 0) {
		obj.value = "";
		obj.dispatchEvent(new Event('input', {bubbles:true}));
	}
	else if (navigator.clipboard.readText) navigator.clipboard.readText().then(function(text) {
		obj.value = text;
		obj.dispatchEvent(new Event('input', {bubbles:true}));
	}).catch(function() {
		obj.value = clipboardText;
		obj.dispatchEvent(new Event('input', {bubbles:true}));
	});
	else if (clipboardText) {
		obj.value = clipboardText;
		obj.dispatchEvent(new Event('input', {bubbles:true}));
	}
}

function unitFromRaw(symbol, str) {
	let shift = ccc[symbol].shift;
	let n = str.toString();	
	while (n.length < shift + 1) {
		n = '0' + n;
	}
	let whole = n.substring(0, n.length - shift);
	let cut = 0;
	while (n[n.length - 1 - cut] == '0' && cut < shift - 2) cut++;
	let fraction = n.substring(n.length - shift, n.length - cut);	
	return whole + '.' + fraction;	
}

function rawFromUnit(symbol, str) {
	let shift = ccc[symbol].shift;
	let parts = str.toString().split(".");	
	let whole = parts[0];
	let fraction = '';
	if (parts.length > 1) fraction = parts[1];
	while (fraction.length < shift) {
		fraction += '0';
	}
	return `${whole}${fraction}`;
}

//////////////////////////////////////////////////////// QR helper functions

function qrclose() {
	if (qrScanning) {
		D(qrScanningSymbol + "-qrButton1").classList.remove('active');
		D(qrScanningSymbol + "-qrButton2").classList.remove('active');
		
		qrScanning.hidden = true;
		if (qrScanningType == "-dest") qrScanning.id = qrScanningSymbol + "-qr-canvas";
		else if (qrScanningType == "-seed") qrScanning.id = qrScanningSymbol + "-qr-canvas-seed";
		
		qrScanning = false;		
		qrScanningType = "";
		
		video.srcObject.getTracks().forEach(track => { track.stop(); });
	}
}

window.qrcode.callback = res => {
	if (res) {
		if (D(qrScanningSymbol + qrScanningType)) {
			if (qrScanningType == "-dest") {
				const nano_scheme = /^(nano):.+$/g;
				if (ccc[qrScanningSymbol].checkAddress(res)) {
					D(qrScanningSymbol + qrScanningType).value = res;
					D(qrScanningSymbol + qrScanningType).dispatchEvent(new Event('input', {bubbles:true}));
					showMsg("Destination address scanned.");
				} else if (qrScanningSymbol == "XNO" && nano_scheme.test(res)) {
					const url = new URL(res);
					if (url.protocol === 'nano:' && ccc[qrScanningSymbol].checkAddress(url.pathname)) {
						D(qrScanningSymbol + qrScanningType).value = url.pathname;
						D(qrScanningSymbol + qrScanningType).dispatchEvent(new Event('input', {bubbles:true}));
						D(qrScanningSymbol + "-withdrawal-amount").value = unitFromRaw('XNO', url.searchParams.get('amount'));
						showMsg("Bill scanned.");
					}
				} else showMsg("Not a valid address: " + res);
			}
			
			if (qrScanningType == "-seed") {
				if (ccc[qrScanningSymbol].checkSeed(res)) {
					D(qrScanningSymbol + qrScanningType).value = res;
					showMsg("Scanned a " + ccc[qrScanningSymbol].keyType + ".");
				} else showMsg("Not a valid " + ccc[qrScanningSymbol].keyType + ": " + res);
			}
		}
		qrclose();
	}
};

function qrscan(symbol, type) {
	if (!qrScanning) {
		navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(function(stream) {
			D(symbol + "-qrButton1").classList.add('active');
			D(symbol + "-qrButton2").classList.add('active');
			
			if (type == "-dest") qrScanning = D(symbol + "-qr-canvas");
			if (type == "-seed") qrScanning = D(symbol + "-qr-canvas-seed");
			qrScanningType = type;
			qrScanningSymbol = symbol;
			
			qrScanning.hidden = false;
			qrScanning.id = "qr-canvas";
			
			video.setAttribute("playsinline", true); // required to tell iOS safari we don't want fullscreen
			video.srcObject = stream;
			video.play();
			
			const canvas = qrScanning.getContext("2d");
			tick();
			scan();
			
			if (screen.width <= 550 || screen.height <= 550) {
				qrScanning.parentNode.scrollIntoView({block:"start", behavior:"auto"});
				setTimeout(function() {qrScanning.parentNode.scrollIntoView({block:"start", behavior:"auto"});}, 200);
				setTimeout(function() {qrScanning.parentNode.scrollIntoView({block:"start", behavior:"auto"});}, 400);
				setTimeout(function() {qrScanning.parentNode.scrollIntoView({block:"start", behavior:"auto"});}, 600);
			}
			
			function tick() {
				if (qrScanning) {
					qrScanning.height = video.videoHeight;
					qrScanning.width = video.videoWidth;
					canvas.drawImage(video, 0, 0, qrScanning.width, qrScanning.height);
					if (qrScanning) requestAnimationFrame(tick);
				}
			}

			function scan() {
				if (qrScanning) {
					try { window.qrcode.decode();} 
					catch (e) { setTimeout(scan, 300);}
				}
			}
		});
	} else qrclose();
}

function addressQR(symbol) {
	if (ccc[symbol].address) {
		D(symbol + '-qr-input').value = ccc[symbol].address;
		D(symbol + '-qr-input').dispatchEvent(new Event('input', {bubbles:true}));
		flash(D(symbol + '-qr-input'));
		ccc[symbol].qrCode.makeCode(ccc[symbol].address);
	}
}

function generateQR(symbol, input) {	
	if (ccc[symbol].checkSeed(input)) {
		D(symbol + '-type-display').textContent = ccc[symbol].keyType;		
		fetchDisplayName(symbol, '-directory-display', ccc[symbol].addressFromSeed(input));
	} else if (ccc[symbol].checkAddress(input)) {
		D(symbol + '-type-display').textContent = 'public address';
		fetchDisplayName(symbol, '-directory-display', input);
	} else {
		D(symbol + '-type-display').textContent = '';
		D(symbol + '-directory-display').textContent = '';
	}
	if (input) ccc[symbol].qrCode.makeCode(input); 
	else ccc[symbol].qrCode.makeCode('');
}

//////////////////////////////////////////////////////// General helper functions

function hideServerMsg() {
	D('serverMsg').style.display = "none";
	D('serverMsgButton').style.display = "none";
	localStorage.setItem("serverMsg", D('serverMsg').textContent);
}

function updateView() {
	let symbol = D('primary').value;
	
	let seed = localStorage.getItem(`${symbol}-seed`);
	if (seed && (D(symbol + "-tool1").style.display == "none" || D(`${symbol}-seed`).value == "")) {
		if (D(`${symbol}-seed`).type != "password") toggleVisibility(symbol);
		D(`${symbol}-seed`).value = seed;
		D(`${symbol}-generateButton`).disabled = true;
		let index = localStorage.getItem(`${symbol}-index`);
		if (index) D(`${symbol}-index`).value = index; 
	}
	
	if (fullView) {
		D(symbol + "-tool1").style.display = "";
		if (symbol == "XNO" || symbol == "BAN") D(symbol + "-tool2").style.display = "";
		D(symbol + "-tool3").style.display = "";
		D("view").classList.add('active');
	} else {
		if (ccc[symbol].address) D(symbol + "-tool1").style.display = "none";
		else D(symbol + "-tool1").style.display = "";
		D(symbol + "-tool2").style.display = "none";
		D(symbol + "-tool3").style.display = "none";
		D("view").classList.remove('active');
	}
}

function enqueue(symbol, func) {
	ccc[symbol].queue = ccc[symbol].queue.then(func);
	return ccc[symbol].queue;
}

var msgTimer;
function showMsg(str, bold, hold) {
	let e = new Date();
	D('msg').style.display = "";
	D('msg').style.transition = "";
	if (msgTimer) clearTimeout(msgTimer);
	D('msg').style.filter = "opacity(0.9)";
	flash(D('msg'), e.toLocaleTimeString() + ": " + str);
	if (bold) D('msg').style.backgroundColor = "#F00";
	if (!hold) msgTimer = setTimeout(function() {
		D('msg').style.transition = "filter 2s linear 0s";
		D('msg').style.filter = "opacity(0)";
	}, 5000);
}

function flash(elt, str) {
	if (str != undefined) elt.textContent = str;
	elt.style.backgroundColor = ccc[D('primary').value].flashColor;	
	setTimeout(function() {	elt.style.backgroundColor = "white";}, 500);
}

function clearDOM(myNode) {	
	while (myNode.firstChild) {
		myNode.removeChild(myNode.lastChild);
	}
}

function make(string, myClass) { 
	let myObj = document.createElement(string);
	if (myClass) myObj.classList.add(myClass);
	return myObj;
}

function clickCopy(elt, str) {
	if (str.length > 1) {
		/* Copy the text inside the text field */
		navigator.clipboard.writeText(str);
		clipboardText = str;
		showMsg("Copied to clipboard.");
	}
	flash(elt);
}

function addOrdered(li, element) {
	for (let j = 0; j < element.children.length; j++) {
		if (parseFloat(li.title) > parseFloat(element.children[j].title)) {
			element.insertBefore(li, element.children[j]);
			return true;
		}
	}
	element.appendChild(li);
}

function convertTimestamp(d) {
  //  let d = new Date(timestamp * 1000), // Convert the passed timestamp to milliseconds
        let yyyy = d.getFullYear(),
        mm = ('0' + (d.getMonth() + 1)).slice(-2),  // Months are zero based. Add leading 0.
        dd = ('0' + d.getDate()).slice(-2),         // Add leading 0.
        hh = d.getHours(),
        h = hh,
        min = ('0' + d.getMinutes()).slice(-2),     // Add leading 0.
        ampm = 'AM',
        time;

    if (hh > 12) {
        h = hh - 12;
        ampm = 'PM';
    } else if (hh === 12) {
        h = 12;
        ampm = 'PM';
    } else if (hh == 0) h = 12;

    // ie: 2014-03-24, 3:00 PM
    time = yyyy + '-' + mm + '-' + dd + ' ' + h + ':' + min + ' ' + ampm;
    return time;
}

function post(url, params) {
    return new Promise((resolve, reject) => {
        let xhttp = new XMLHttpRequest();
        xhttp.timeout = 10*1000; // 10 seconds
        xhttp.onreadystatechange = function() {
			if (this.readyState == 4) {
				if (this.status == 200) {
					try { resolve(JSON.parse(this.responseText)); } 
					catch(e) {
						console.error('Failed to parse response from node');
						console.error(this.responseText);
						resolve();
					}
				} else {
					console.log('Failed to connect to '+ url);
					showMsg('Unable to connect to network.');
					resolve();
				}
			}
        };
        xhttp.open("POST", url, true);
        xhttp.setRequestHeader("Content-Type", "application/json");
        xhttp.send(JSON.stringify(params));
    });
}


function D(string) { return document.getElementById(string); }	

let deferredInstallPrompt = null;
D('installButton').addEventListener('click', function(event) {
	deferredInstallPrompt.prompt();
	
	// CODELAB: Log user response to prompt.  
	deferredInstallPrompt.userChoice.then((choice) => {
		if (choice.outcome === 'accepted') {
		  console.log('User accepted the A2HS prompt', choice);
		  evt.srcElement.style.display = 'none';
		} else console.log('User dismissed the A2HS prompt', choice);
		deferredInstallPrompt = null;
	});
});

// CODELAB: Add event listener for beforeinstallprompt event
window.addEventListener('beforeinstallprompt', function (evt) {  // CODELAB: Add code to save event & show the install button.  
	console.log("Detected that PWA can be installed.");
    deferredInstallPrompt = evt;
    evt.preventDefault();
    D('installButton').style.display = 'inline';
});

window.addEventListener('appinstalled', function (evt) {  // CODELAB: Add code to log the event  
    console.log('Ansyble was installed.', evt);
});

function selectPrimary(symbol) {
	localStorage.setItem('symbol', symbol);
	qrclose();
	D('firstDiv').style.backgroundColor = ccc[symbol].bgColor;
	
	D('firstDiv').removeChild(D('firstDiv').lastChild);
	D('secondDiv').removeChild(D('secondDiv').lastChild);
	
	D('firstDiv').appendChild(ccc[symbol].sidebarElt);
	D('secondDiv').appendChild(ccc[symbol].transactionElt);
	
	updateView(symbol);
	if (ccc[symbol].faucet) D(`${symbol}-faucet`).style.display = "";
	if (!ccc[symbol].qrCode) ccc[symbol].qrCode = new QRCode(symbol + "-qrCodeImageBlock");
	
	if (symbol != "XNO" && symbol != "BAN") {
		D(`${symbol}-index`).style.display = "none";
		D(`${symbol}-tool2`).style.display = "none";
		D(`${symbol}-arriving-balance-panel`).style.display = "none";
	} else {
		D(`${symbol}-seed`).maxLength = "64";
		D(`${symbol}-seed`).placeholder = "Seed (store securely) ...";
	}
	
	if (ccc[symbol].address) {
		refreshBalance(symbol);
		ccc[symbol].getTransactions();	
	} else if (localStorage.getItem(`${symbol}-seed`)) importWallet(symbol);
}
	
function generateHTML(symbol) {
	ccc[symbol].transactionElt = make('div');
	ccc[symbol].transactionElt.innerHTML = `	
	<div id="${symbol}-gray2">
		<div style="max-width:620px; margin-top:30px; display:flex; align-items:center; justify-content:space-between">
			<strong id="${symbol}-heading" style="font-size:1.2em">Transactions</strong>
			<button style="font-size:0.8em" onclick="refreshBalance('${symbol}'); ccc['${symbol}'].getTransactions();">Refresh</button>
		</div>
		<ul id="${symbol}-transactions" style="padding-left:0px; max-width:620px; list-style: none;"></ul>
		<div style="max-width:620px; margin-top:30px; margin-bottom:70px; text-align:center">
			<button style="display:none" id="${symbol}-loadMore">Load More</button>
			<div id="${symbol}-gettingStarted">
				<div id="${symbol}-faucet" style="display:none"><a href="${ccc[symbol].faucet}" rel="noopener" target="_blank">Free ${symbol} for testing</a></div>
				<div><a href="${ccc[symbol].gettingStarted}" rel="noopener" target="_blank">${symbol} information, resources, and links</a></div>
			</div>
		</div>
	</div>`;
		
	ccc[symbol].sidebarElt = make('div');
	ccc[symbol].sidebarElt.innerHTML = `
	<div id="${symbol}-tool1" class="objectWrapper">
		<div style="text-align:center;">
		<button tabindex="-1" id="${symbol}-generateButton" style="font-size:0.8em" onclick="generateWallet('${symbol}')">Generate New</button>
		<button tabindex="-1" id="${symbol}-qrButton1" style="font-size:0.8em" onclick="qrscan('${symbol}', '-seed')">Scan QR Code</button>
		</div>
		<div style="display:flex; justify-content:space-between; margin-top:15px;">
			<input onfocus="scrollPanel(this.parentNode)" placeholder="Private key (store securely) ..." id="${symbol}-seed" style="padding-right:30px; flex-grow:1; flex-basis:20px; margin-right:10px;" type="password" autocomplete="off" onclick="this.select()" onkeyup="if (event.keyCode == 13) importWallet('${symbol}')" oninput="if (this.value.length == 0) D('${symbol}-generateButton').disabled = false; else D('${symbol}-generateButton').disabled = true;">
			<button class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
			<div>
				<button id="${symbol}-show" tabindex="-1" style="font-size:0.8em" onclick="toggleVisibility('${symbol}')">Show</button>
			</div>			
		</div>
		<canvas style="width:100%; margin-top:10px;" hidden="" id="${symbol}-qr-canvas-seed"></canvas>
		<input onfocus="scrollPanel(this)" placeholder="Account index (default 0; or 1, 2, 3, etc) ..." id="${symbol}-index" type="number" style="margin-top:15px; width:calc(100% - 70px)" min="0" maxlength="64" onclick="this.select()" onkeyup="if (event.keyCode == 13) importWallet('${symbol}')">
		<div style="text-align:center;">
		<button style="margin-top:15px;" id="${symbol}-load" onclick="importWallet('${symbol}')">Load Account</button>
		</div>
	</div>
	<div id="${symbol}-gray" style="margin-top:20px; margin-bottom:20px; display:none; filter:opacity(1)">
	<div class="objectWrapper">
		<div style="display:flex; align-items:center; justify-content:space-between">
			<strong><div id="${symbol}-display" style="font-size:1.2em" onclick="fetchDisplayName('${symbol}', '-display', ccc['${symbol}'].address, true)">My Account (Unknown)</div></strong>
			<button id="${symbol}-editbutton" style="font-size:0.8em" onclick="toggleEdit('${symbol}')">Edit</button>
		</div>
		
		<div id="${symbol}-editpanel" style="display:none; margin-left:20px; margin-right:20px; margin-top:10px; margin-bottom:20px">			
			<div style="display:flex; justify-content:space-between;">
				<input placeHolder="Public display name..." onfocus="scrollPanel(this.parentNode.parentNode)" id="${symbol}-set-display" style="padding-right:30px; flex-grow:1; margin-right:10px;" type="text" maxlength="64" onkeyup="if (event.keyCode == 13) setName('${symbol}'); if (event.keyCode == 27) this.value = '';"><button class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
				<button style="font-size:0.8em" onclick="setName('${symbol}')">Set</button>
			</div>
		</div>
		
		
		<div style="margin-bottom:15px">
		<div style="overflow:hidden; text-overflow:ellipsis; cursor:pointer; font-size:0.8em" id="${symbol}-address" onclick="clickCopy(this, this.textContent)">&nbsp;</div>
		</div>
		
		<div style="margin-top:10px; display:flex; align-items:center; justify-content:space-between">
			<div style="width:calc(100% - 65px); display:flex">
				<strong>Balance:&nbsp;</strong> 
				<span id="${symbol}-balance" style="cursor:pointer; max-width:min-content; overflow:hidden; text-overflow:ellipsis;" onclick="clickCopy(this, this.textContent)">0.00</span>&nbsp;${symbol}&nbsp;
			</div>
			<button style="font-size:0.8em" onclick="refreshBalance('${symbol}'); ccc['${symbol}'].getTransactions();">Refresh</button>
		</div>
		<div id="${symbol}-arriving-balance-panel" style="margin-top:10px; display:flex; align-items:center; justify-content:space-between">
			<div style="width:calc(100% - 65px); display:flex">
				<strong style="white-space:nowrap">Arriving balance:&nbsp;</strong> 
				<span id="${symbol}-balance-pending" style="cursor:pointer; max-width:min-content; overflow:hidden; text-overflow:ellipsis;" onclick="clickCopy(this, this.textContent)">0.00</span>&nbsp;${symbol}&nbsp;
			</div>
			<button style="font-size:0.8em" onclick="cyclePending('${symbol}')">Collect</button>
		</div>
	</div>

	<div class="objectWrapper" style='margin-bottom:20px'>
		<strong>Destination: </strong><span id="${symbol}-dest-display"></span>
		<div style="display:flex; justify-content:space-between">
			<input placeholder="Destination address..." onfocus="scrollPanel(this.parentNode)" style="padding-right:30px; flex-grow:1; margin-right:10px" id="${symbol}-dest" type="text" maxlength="128" onclick="this.select()" oninput="fetchDisplayName('${symbol}', '-dest-display', this.value)"><button class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
			<button id="${symbol}-qrButton2" style="font-size:0.8em" onclick="qrscan('${symbol}', '-dest')">QR</button>
		</div>		
		<canvas style="width:100%; margin-top:10px;" hidden="" id="${symbol}-qr-canvas"></canvas>
		
		<div style="display:flex; justify-content:space-between; margin-top:15px; margin-right:15px; align-items:baseline">
			<strong>Amount:&nbsp;</strong>
			<input placeholder="0.00" onkeyup="if (event.keyCode == 27) this.value = '';" style="text-align:right; flex-grow:1; flex-basis:1px" onfocus="scrollPanel(this.parentNode)" id="${symbol}-withdrawal-amount" type="number" step="0.01" min="0">&nbsp; ${symbol}
		</div>
		
		<div style="display:none; justify-content:space-between; margin-top:15px; margin-right:15px; align-items:baseline">
			<strong>Network fee:&nbsp;</strong>
			<input placeholder="0.00" onkeyup="if (event.keyCode == 27) this.value = '';" style="text-align:right; flex-grow:1; flex-basis:1px" onfocus="scrollPanel(this.parentNode)" id="${symbol}-withdrawal-fee" type="number" step="0.01" min="0">&nbsp; ${symbol}
		</div>
		
		<div style="text-align:center;">
			<button style="margin-top:15px" onclick="withdraw('${symbol}')">Transfer ${symbol}</button>
		</div>
	</div>
		
	<div id="${symbol}-tool2" class="objectWrapper">
		<strong>Current representative: </strong><span id="${symbol}-rep-display"></span>
		<div style="margin-bottom:10px; overflow:hidden; text-overflow:ellipsis; cursor:pointer; font-size:0.8em" id="${symbol}-rep" onclick="clickCopy(this, this.textContent)">&nbsp;</div>
		<strong>New representative: </strong><span id="${symbol}-new-rep-display"></span>	
		<div style="display:flex; justify-content:space-between">
			<input placeholder="New representative address..." onfocus="scrollPanel(this.parentNode)" style="padding-right:30px; flex-grow:1; margin-right:10px" id="${symbol}-new-rep" type="text" maxlength="128" onclick="this.select()" oninput="fetchDisplayName('${symbol}', '-new-rep-display', this.value)" onkeyup="if (event.keyCode == 13) setRep('${symbol}')"><button class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
			<button style="font-size:0.8em" onclick="suggestRep('${symbol}')">Suggest</button>
		</div>
		<div style="text-align:center;">
		<button style="margin-top:15px" onclick="setRep('${symbol}')">Set Representative</button>	
		</div>
	</div>
		
	<div id="${symbol}-tool3" class="objectWrapper" style="padding-bottom:20px">
		<strong>Device-to-device communication:</strong>
		<div style="margin-bottom:10px; display:flex; justify-content:space-between">
			<input placeholder="Text to QR-encode..." onfocus="scrollPanel(this.parentNode)" style="padding-right:30px; flex-grow:1; margin-right:10px" id="${symbol}-qr-input" type="text" maxlength="512" onclick="this.select()" oninput="generateQR('${symbol}', this.value)"><button class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
			<button style="font-size:0.8em" onclick="addressQR('${symbol}')">My Address</button>
		</div>				
		<strong>Owner: </strong><span id="${symbol}-directory-display"></span>	
		<br><strong>Type: </strong><span id="${symbol}-type-display"></span>	
		<div style="margin-top:20px; display:flex; justify-content:center" id="${symbol}-qrCodeImageBlock"></div>
	</div>
		
	<div style="text-align:center; margin-top:30px; margin-bottom:120px;">		
			<button id="installButton" style="font-size:0.8em; display:none; margin-right:15px;">Native App</button>
		<button style="font-size:0.8em;" onclick="donate('${symbol}')">Donate!</button>
		<button style="font-size:0.8em" onclick="if (confirm('Clear all data for ${symbol} including the wallet seed and private keys?')) {
													clickClearWallet('${symbol}'); showMsg('${symbol} wallet cleared.'); }">Clear ${symbol} Wallet</button>
	</div>
	</div>`;
}

</script>
</html>
